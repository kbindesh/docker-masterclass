# Advanced Docker Image concepts

## 01. Multi-stage builds (Dockerfile)

### Step-1.1: Hands-on Lab - `Multi-stage builds (Dockerfile)`

- To demonstrate why a Dockerfile with multiple build steps is useful, let's write an example Dockerfile.

Let's develop and use a _Hello World_ application written in C programming language.

```
#include <stdio.h>

int main()
{

 printf("Hello World");

 return 0;
}
```

### Step-1.2: To containerize this application, let's write a `Dockerfile`

```
FROM alpine:latest
RUN mkdir -p /var/c-app
WORKDIR /var/c-app
COPY . .
RUN apk update && apk add gcc musl-dev --no-cache
RUN gcc app.c -o app
CMD ["./app"]
```

### Step-1.3: Build the docker image of above C app

```
docker image build -t hello-world .
```

- The preceding command takes fairly a long time to build the image for the first time since the docker builder has to install the following software while building an image:

  - Alpine Software Development Kit (SDK)
  - C compiler (to build the application)

### Step-1.4: List docker image

```
docker image ls | grep hello-world

[Notice the image name & size column (> 200MB)]
```

- The resulting image will be way to big for a simple _hello world_ app.
- The reason image being so big is that the image not only contains the _Hello World_ binary but also the tools to compile and link the app from the source code.

### Step-1.5: Optimize the Image by building `Dockerfile with multi-stages`

- Create a new Dockerfile called _Dockerfile.multi-step_ with the following contents:

```
FROM alpine:latest AS build
RUN mkdir -p /var/c-app
WORKDIR /var/c-app
COPY . .
RUN apk update && apk add gcc musl-dev --no-cache
RUN gcc app.c -o app
CMD ["./app"]

FROM alpine:3.12
COPY --from=build /var/c-app/app /var/c-app/app
CMD ["./app"]
```

### Step-1.6: Build the image again (this time Dockerfile with two stages)

```
docker image build -t hello-world-small -f Dockerfile.multi-step .
```

### Step-1.7: List & Compare the sizes of both the images

```
docker image ls | grep hello-world
```

- You will observe that the size of the image has been reduced drastically from 215 MB down to 5.34 MB.

## 02. `.dockerignore file`

- The _.dockerignore_ file is a text file that tells Docker to ignore certain files and directories when
  building a Docker image from a Dockerfile.
- It is similar to how the .gitignore file works in Git.
- If the directory contains large files or directories that are not necessary for building the Docker image, you can mention it in the .dockerignore file.

```
# Sample .dockerignore file

# Ignore everything
**

# Allow specific directories
!my-app/
!scripts/

# Ignore specific files within allowed directories
my-app/*.log
scripts/temp/
```

## 03. How to optimze Docker Images

- **Method-01** : Using `distribution less images `(java, python, rust) or `minimal base images` (alpine)
- **Method-02** : Using `multi-stage builds`
- **Method-03** : Minimizing the number of layers
- **Method-04** : Understanding `caching`
- **Method-05** : Using `.dockerignore`
- **Method-06** : Keeping application data elsewhere and not in the image
